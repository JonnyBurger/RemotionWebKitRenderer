{"version":3,"file":"783.bundle.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvNA;AACA;;;;;;;;;;;;;;;;;ACDA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAIA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;;;;;;;;;;AChCA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;;;;;AChBA;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAEA;AAAA;AAEA","sources":["../../node_modules/.pnpm/@react-gifs+tools@0.1.2_zpnidt7m3osuk7shl3s4oenomq/node_modules/@react-gifs/tools/dist/index.esm.js","../../node_modules/.pnpm/gifuct-js@2.1.1/node_modules/gifuct-js/lib/deinterlace.js","../../node_modules/.pnpm/gifuct-js@2.1.1/node_modules/gifuct-js/lib/index.js","../../node_modules/.pnpm/gifuct-js@2.1.1/node_modules/gifuct-js/lib/lzw.js","../../node_modules/.pnpm/js-binary-schema-parser@2.0.2/node_modules/js-binary-schema-parser/lib/index.js","../../node_modules/.pnpm/js-binary-schema-parser@2.0.2/node_modules/js-binary-schema-parser/lib/parsers/uint8.js","../../node_modules/.pnpm/js-binary-schema-parser@2.0.2/node_modules/js-binary-schema-parser/lib/schemas/gif.js","../../node_modules/.pnpm/lru_map@0.4.1/node_modules/lru_map/dist/lru.js","./src/GifTest/index.tsx","../gif/dist/Gif.js","../gif/dist/GifForDevelopment.js","../gif/dist/GifForRendering.js","../gif/dist/index.js","../gif/dist/props.js","../gif/dist/useCurrentGifIndex.js"],"sourcesContent":["import React, { useReducer, useCallback, useEffect, useRef, useLayoutEffect, forwardRef } from 'react';\nimport { parseGIF, decompressFrames } from 'gifuct-js';\n\nconst reducer = (state, action = {}) => {\n  if (typeof action === \"function\") {\n    action = action(state);\n  }\n\n  const isLoadedChange = action.loaded && state.loaded !== action.loaded;\n  const {\n    playing,\n    ...rest\n  } = action;\n  const copy = { ...state,\n    ...rest\n  };\n\n  if (isLoadedChange) {\n    Object.assign(copy, {\n      playing: copy.autoPlay && copy.loaded\n    });\n  }\n\n  if (action.delays != null || action.frames != null) {\n    Object.assign(copy, {\n      length: copy.frames.length\n    });\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (copy.frames.length !== copy.delays.length) throw Error(\"frames and delays have different sizes\");\n    }\n  }\n\n  if (action.index != null || action.frames != null) {\n    Object.assign(copy, {\n      index: copy.length === 0 ? 0 : (copy.length + copy.index) % copy.length\n    });\n  }\n\n  if (action.playing != null) {\n    Object.assign(copy, copy.loaded ? {\n      playing\n    } : {\n      autoPlay: playing\n    });\n  }\n\n  return copy;\n};\n\nconst initializer = stateOrFn => reducer({\n  autoPlay: true,\n  playing: false,\n  frames: [],\n  delays: [],\n  index: 0,\n  length: 0,\n  loaded: false\n}, stateOrFn);\n\nconst usePlayerState = stateOrFn => {\n  return useReducer(reducer, stateOrFn, initializer);\n};\n\nvar code = \"function e(e){var r={exports:{}};return e(r,r.exports),r.exports}var r=e((function(e,r){Object.defineProperty(r,\\\"__esModule\\\",{value:!0}),r.loop=r.conditional=r.parse=void 0;r.parse=function e(r,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;if(Array.isArray(t))t.forEach((function(t){return e(r,t,n,a)}));else if(\\\"function\\\"==typeof t)t(r,n,a,e);else{var i=Object.keys(t)[0];Array.isArray(t[i])?(a[i]={},e(r,t[i],n,a[i])):a[i]=t[i](r,n,a,e)}return n};r.conditional=function(e,r){return function(t,n,a,i){r(t,n,a)&&i(t,e,n,a)}};r.loop=function(e,r){return function(t,n,a,i){for(var o=[];r(t,n,a);){var s={};i(t,e,n,s),o.push(s)}return o}}})),t=e((function(e,r){Object.defineProperty(r,\\\"__esModule\\\",{value:!0}),r.readBits=r.readArray=r.readUnsigned=r.readString=r.peekBytes=r.readBytes=r.peekByte=r.readByte=r.buildStream=void 0;r.buildStream=function(e){return{data:e,pos:0}};var t=function(){return function(e){return e.data[e.pos++]}};r.readByte=t;r.peekByte=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return function(r){return r.data[r.pos+e]}};var n=function(e){return function(r){return r.data.subarray(r.pos,r.pos+=e)}};r.readBytes=n;r.peekBytes=function(e){return function(r){return r.data.subarray(r.pos,r.pos+e)}};r.readString=function(e){return function(r){return Array.from(n(e)(r)).map((function(e){return String.fromCharCode(e)})).join(\\\"\\\")}};r.readUnsigned=function(e){return function(r){var t=n(2)(r);return e?(t[1]<<8)+t[0]:(t[0]<<8)+t[1]}};r.readArray=function(e,r){return function(t,a,i){for(var o=\\\"function\\\"==typeof r?r(t,a,i):r,s=n(e),d=new Array(o),c=0;c<o;c++)d[c]=s(t);return d}};r.readBits=function(e){return function(r){for(var t=function(e){return e.data[e.pos++]}(r),n=new Array(8),a=0;a<8;a++)n[7-a]=!!(t&1<<a);return Object.keys(e).reduce((function(r,t){var a=e[t];return a.length?r[t]=function(e,r,t){for(var n=0,a=0;a<t;a++)n+=e[r+a]&&Math.pow(2,t-a-1);return n}(n,a.index,a.length):r[t]=n[a.index],r}),{})}}})),n=e((function(e,n){Object.defineProperty(n,\\\"__esModule\\\",{value:!0}),n.default=void 0;var a={blocks:function(e){for(var r=[],n=e.data.length,a=0,i=(0,t.readByte)()(e);0!==i;i=(0,t.readByte)()(e)){if(e.pos+i>=n){var o=n-e.pos;r.push((0,t.readBytes)(o)(e)),a+=o;break}r.push((0,t.readBytes)(i)(e)),a+=i}for(var s=new Uint8Array(a),d=0,c=0;c<r.length;c++)s.set(r[c],d),d+=r[c].length;return s}},i=(0,r.conditional)({gce:[{codes:(0,t.readBytes)(2)},{byteSize:(0,t.readByte)()},{extras:(0,t.readBits)({future:{index:0,length:3},disposal:{index:3,length:3},userInput:{index:6},transparentColorGiven:{index:7}})},{delay:(0,t.readUnsigned)(!0)},{transparentColorIndex:(0,t.readByte)()},{terminator:(0,t.readByte)()}]},(function(e){var r=(0,t.peekBytes)(2)(e);return 33===r[0]&&249===r[1]})),o=(0,r.conditional)({image:[{code:(0,t.readByte)()},{descriptor:[{left:(0,t.readUnsigned)(!0)},{top:(0,t.readUnsigned)(!0)},{width:(0,t.readUnsigned)(!0)},{height:(0,t.readUnsigned)(!0)},{lct:(0,t.readBits)({exists:{index:0},interlaced:{index:1},sort:{index:2},future:{index:3,length:2},size:{index:5,length:3}})}]},(0,r.conditional)({lct:(0,t.readArray)(3,(function(e,r,t){return Math.pow(2,t.descriptor.lct.size+1)}))},(function(e,r,t){return t.descriptor.lct.exists})),{data:[{minCodeSize:(0,t.readByte)()},a]}]},(function(e){return 44===(0,t.peekByte)()(e)})),s=(0,r.conditional)({text:[{codes:(0,t.readBytes)(2)},{blockSize:(0,t.readByte)()},{preData:function(e,r,n){return(0,t.readBytes)(n.text.blockSize)(e)}},a]},(function(e){var r=(0,t.peekBytes)(2)(e);return 33===r[0]&&1===r[1]})),d=(0,r.conditional)({application:[{codes:(0,t.readBytes)(2)},{blockSize:(0,t.readByte)()},{id:function(e,r,n){return(0,t.readString)(n.blockSize)(e)}},a]},(function(e){var r=(0,t.peekBytes)(2)(e);return 33===r[0]&&255===r[1]})),c=(0,r.conditional)({comment:[{codes:(0,t.readBytes)(2)},a]},(function(e){var r=(0,t.peekBytes)(2)(e);return 33===r[0]&&254===r[1]})),u=[{header:[{signature:(0,t.readString)(3)},{version:(0,t.readString)(3)}]},{lsd:[{width:(0,t.readUnsigned)(!0)},{height:(0,t.readUnsigned)(!0)},{gct:(0,t.readBits)({exists:{index:0},resolution:{index:1,length:3},sort:{index:4},size:{index:5,length:3}})},{backgroundColorIndex:(0,t.readByte)()},{pixelAspectRatio:(0,t.readByte)()}]},(0,r.conditional)({gct:(0,t.readArray)(3,(function(e,r){return Math.pow(2,r.lsd.gct.size+1)}))},(function(e,r){return r.lsd.gct.exists})),{frames:(0,r.loop)([i,d,c,o,s],(function(e){var r=(0,t.peekByte)()(e);return 33===r||44===r}))}];n.default=u})),a=e((function(e,r){Object.defineProperty(r,\\\"__esModule\\\",{value:!0}),r.deinterlace=void 0;r.deinterlace=function(e,r){for(var t=new Array(e.length),n=e.length/r,a=function(n,a){var i=e.slice(a*r,(a+1)*r);t.splice.apply(t,[n*r,r].concat(i))},i=[0,4,2,1],o=[8,8,4,2],s=0,d=0;d<4;d++)for(var c=i[d];c<n;c+=o[d])a(c,s),s++;return t}})),i=e((function(e,r){Object.defineProperty(r,\\\"__esModule\\\",{value:!0}),r.lzw=void 0;r.lzw=function(e,r,t){var n,a,i,o,s,d,c,u,l,f,p,g,y,h,v,m,x=4096,B=t,w=new Array(t),b=new Array(x),k=new Array(x),A=new Array(4097);for(s=(a=1<<(f=e))+1,n=a+2,c=-1,i=(1<<(o=f+1))-1,u=0;u<a;u++)b[u]=0,k[u]=u;for(p=g=y=h=v=m=0,l=0;l<B;){if(0===h){if(g<o){p+=r[m]<<g,g+=8,m++;continue}if(u=p&i,p>>=o,g-=o,u>n||u==s)break;if(u==a){i=(1<<(o=f+1))-1,n=a+2,c=-1;continue}if(-1==c){A[h++]=k[u],c=u,y=u;continue}for(d=u,u==n&&(A[h++]=y,u=c);u>a;)A[h++]=k[u],u=b[u];y=255&k[u],A[h++]=y,n<x&&(b[n]=c,k[n]=y,0==(++n&i)&&n<x&&(o++,i+=n)),c=d}h--,w[v++]=A[h],l++}for(l=v;l<B;l++)w[l]=0;return w}})),o=e((function(e,o){Object.defineProperty(o,\\\"__esModule\\\",{value:!0}),o.decompressFrames=o.decompressFrame=o.parseGIF=void 0;var s,d=(s=n)&&s.__esModule?s:{default:s};o.parseGIF=function(e){var n=new Uint8Array(e);return(0,r.parse)((0,t.buildStream)(n),d.default)};var c=function(e,r,t){if(e.image){var n=e.image,o=n.descriptor.width*n.descriptor.height,s=(0,i.lzw)(n.data.minCodeSize,n.data.blocks,o);n.descriptor.lct.interlaced&&(s=(0,a.deinterlace)(s,n.descriptor.width));var d={pixels:s,dims:{top:e.image.descriptor.top,left:e.image.descriptor.left,width:e.image.descriptor.width,height:e.image.descriptor.height}};return n.descriptor.lct&&n.descriptor.lct.exists?d.colorTable=n.lct:d.colorTable=r,e.gce&&(d.delay=10*(e.gce.delay||10),d.disposalType=e.gce.extras.disposal,e.gce.extras.transparentColorGiven&&(d.transparentIndex=e.gce.transparentColorIndex)),t&&(d.patch=function(e){for(var r=e.pixels.length,t=new Uint8ClampedArray(4*r),n=0;n<r;n++){var a=4*n,i=e.pixels[n],o=e.colorTable[i]||[0,0,0];t[a]=o[0],t[a+1]=o[1],t[a+2]=o[2],t[a+3]=i!==e.transparentIndex?255:0}return t}(d)),d}console.warn(\\\"gif frame does not have associated image.\\\")};o.decompressFrame=c;o.decompressFrames=function(e,r){return e.frames.filter((function(e){return e.image})).map((function(t){return c(t,e.gct,r)}))}}));const s=(e,r,t)=>{const{width:n,height:a,top:i,left:o}=r.dims,s=i*t.width+o;for(let i=0;i<a;i++)for(let a=0;a<n;a++){const o=i*n+a,d=r.pixels[o];if(d!==r.transparentIndex){const n=s+i*t.width+a,o=r.colorTable[d]||[0,0,0];e[4*n]=o[0],e[4*n+1]=o[1],e[4*n+2]=o[2],e[4*n+3]=255}}return e},d=new Map;self.addEventListener(\\\"message\\\",(e=>{const{type:r,src:t}=e.data||e;switch(r){case\\\"parse\\\":if(!d.has(t)){const e=new AbortController,r={signal:e.signal};d.set(t,e),((e,{signal:r})=>fetch(e,{signal:r}).then((e=>{if(!e.headers.get(\\\"Content-Type\\\").includes(\\\"image/gif\\\"))throw Error(`Wrong content type: \\\"${e.headers.get(\\\"Content-Type\\\")}\\\"`);return e.arrayBuffer()})).then((e=>o.parseGIF(e))).then((e=>((e=>{let r=null;for(const t of e.frames)r=t.gce?t.gce:r,\\\"image\\\"in t&&!(\\\"gce\\\"in t)&&(t.gce=r)})(e),e))).then((e=>Promise.all([o.decompressFrames(e,!1),{width:e.lsd.width,height:e.lsd.height}]))).then((([e,r])=>{const t=[],n=r.width*r.height*4;for(let a=0;a<e.length;++a){const i=e[a],o=0===a||2===e[a-1].disposalType?new Uint8ClampedArray(n):t[a-1].slice();t.push(s(o,i,r))}return{...r,loaded:!0,delays:e.map((e=>e.delay)),frames:t}})))(t,r).then((e=>{self.postMessage(Object.assign(e,{src:t}),e.frames.map((e=>e.buffer)))})).catch((e=>{self.postMessage({src:t,error:e,loaded:!0})})).finally((()=>{d.delete(t)}))}break;case\\\"cancel\\\":if(d.has(t)){d.get(t).abort(),d.delete(t)}}}));\\n\";\n\nfunction WorkerFactory(options) {\n  const blob = new Blob([code], {\n    type: 'application/javascript'\n  });\n  const url = URL.createObjectURL(blob);\n  const worker = new Worker(url, options);\n  URL.revokeObjectURL(url);\n  return worker;\n}\n\nconst validateAndFix = gif => {\n  let currentGce = null;\n\n  for (const frame of gif.frames) {\n    currentGce = frame.gce ? frame.gce : currentGce; // fix loosing graphic control extension for same frames\n\n    if (\"image\" in frame && !(\"gce\" in frame)) {\n      frame.gce = currentGce;\n    }\n  }\n};\n\nconst parse = (src, {\n  signal\n}) => fetch(src, {\n  signal\n}).then(resp => {\n  if (!resp.headers.get(\"Content-Type\").includes(\"image/gif\")) throw Error(`Wrong content type: \"${resp.headers.get(\"Content-Type\")}\"`);\n  return resp.arrayBuffer();\n}).then(buffer => parseGIF(buffer)).then(gif => {\n  validateAndFix(gif);\n  return gif;\n}).then(gif => Promise.all([decompressFrames(gif, false), {\n  width: gif.lsd.width,\n  height: gif.lsd.height\n}])).then(([frames, options]) => {\n  const readyFrames = [];\n  const size = options.width * options.height * 4;\n\n  for (let i = 0; i < frames.length; ++i) {\n    const frame = frames[i];\n    const typedArray = i === 0 || frames[i - 1].disposalType === 2 ? new Uint8ClampedArray(size) : readyFrames[i - 1].slice();\n    readyFrames.push(putPixels(typedArray, frame, options));\n  }\n\n  return { ...options,\n    loaded: true,\n    delays: frames.map(frame => frame.delay),\n    frames: readyFrames\n  };\n});\n\nconst putPixels = (typedArray, frame, gifSize) => {\n  const {\n    width,\n    height,\n    top: dy,\n    left: dx\n  } = frame.dims;\n  const offset = dy * gifSize.width + dx;\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const pPos = y * width + x;\n      const colorIndex = frame.pixels[pPos];\n\n      if (colorIndex !== frame.transparentIndex) {\n        const taPos = offset + y * gifSize.width + x;\n        const color = frame.colorTable[colorIndex] || [0, 0, 0];\n        typedArray[taPos * 4] = color[0];\n        typedArray[taPos * 4 + 1] = color[1];\n        typedArray[taPos * 4 + 2] = color[2];\n        typedArray[taPos * 4 + 3] = 255;\n      }\n    }\n  }\n\n  return typedArray;\n};\n\nconst genearate = info => {\n  return { ...info,\n    frames: info.frames.map(buffer => {\n      const image = new ImageData(info.width, info.height);\n      image.data.set(new Uint8ClampedArray(buffer));\n      return image;\n    })\n  };\n};\n\nconst createSingleton = (constructor, destructor) => {\n  const ref = {};\n  return () => {\n    if (!ref.instance) {\n      ref.instance = constructor();\n    }\n\n    useLayoutEffect(() => {\n      if (ref.timeout) {\n        clearTimeout(ref.timeout);\n        delete ref.timeout;\n      } else {\n        ref.usageCount = (ref.usageCount || 0) + 1;\n      }\n\n      return () => {\n        ref.timeout = setTimeout(() => {\n          ref.usageCount = ref.usageCount - 1;\n\n          if (ref.usageCount === 0) {\n            destructor && destructor(ref.instance);\n            delete ref.instance;\n            delete ref.timeout;\n          }\n        });\n      };\n    }, [ref, destructor]);\n    return ref.instance;\n  };\n};\n\nconst useUpdatedRef = value => {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n};\n\nconst useEventCallback = callback => {\n  const ref = useUpdatedRef(callback);\n  return useCallback(arg => ref.current && ref.current(arg), []);\n};\n\nconst useRaf = (callback, pause) => {\n  const cb = useEventCallback(callback);\n  useLayoutEffect(() => {\n    if (!pause) {\n      let id;\n      let prev = null;\n\n      const handleUpdate = () => {\n        id = requestAnimationFrame(now => {\n          const dt = now - (prev || now);\n          prev = now;\n          cb(dt);\n          handleUpdate();\n        });\n      };\n\n      handleUpdate();\n      return () => cancelAnimationFrame(id);\n    }\n  }, [pause, cb]);\n};\n\nconst useAsyncEffect = (fn, deps) => {\n  const cb = useEventCallback(fn);\n  useEffect(() => {\n    const controller = new AbortController();\n    const dest = cb(controller);\n    return () => {\n      controller.abort();\n      dest && dest();\n    };\n  }, [...deps]);\n};\n\nconst useParser = (src, callback) => {\n  const cb = useEventCallback(callback);\n  useAsyncEffect(controller => {\n    if (typeof src === \"string\") {\n      parse(src, {\n        signal: controller.signal\n      }).then(raw => genearate(raw)).then(info => cb(info)).catch(error => cb({\n        error,\n        loaded: true\n      }));\n    }\n  }, [src]);\n};\n\nconst useWorkerSingleton = /*#__PURE__*/createSingleton(() => new WorkerFactory(), worker => worker.terminate());\n\nconst useWorkerParser = (src, callback) => {\n  const cb = useEventCallback(callback);\n  const worker = useWorkerSingleton();\n  useEffect(() => {\n    if (typeof src === \"string\") {\n      const handler = e => {\n        const message = e.data || e;\n\n        if (message.src === src) {\n          const data = message.error ? message : genearate(message);\n          cb(data);\n        }\n      };\n\n      worker.addEventListener(\"message\", handler);\n      worker.postMessage({\n        src,\n        type: \"parse\"\n      });\n      return () => {\n        worker.postMessage({\n          src,\n          type: \"cancel\"\n        });\n        worker.removeEventListener(\"message\", handler);\n      };\n    }\n  }, [worker, src]);\n};\n\nconst usePlayback = (state, updater) => {\n  const delay = useRef(0);\n  useRaf(dt => {\n    const {\n      delays,\n      index: currentIndex\n    } = state;\n    delay.current += dt;\n\n    if (delay.current > delays[currentIndex]) {\n      delay.current = delay.current % delays[currentIndex];\n      updater();\n    }\n  }, !state.playing);\n};\n\nconst calcArgs = (fit, frameSize, canvasSize) => {\n  switch (fit) {\n    case \"fill\":\n      return [0, 0, frameSize.width, frameSize.height, 0, 0, canvasSize.width, canvasSize.height];\n\n    case \"contain\":\n      {\n        const ratio = Math.min(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n        const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n        const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n        return [0, 0, frameSize.width, frameSize.height, centerX, centerY, frameSize.width * ratio, frameSize.height * ratio];\n      }\n\n    case \"cover\":\n      {\n        const ratio = Math.max(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n        const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n        const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n        return [0, 0, frameSize.width, frameSize.height, centerX, centerY, frameSize.width * ratio, frameSize.height * ratio];\n      }\n\n    default:\n      return [0, 0];\n  }\n};\n\nconst combine = (...refs) => value => {\n  refs.forEach(ref => {\n    if (typeof ref === \"function\") {\n      ref(value);\n    } else if (ref != null) {\n      ref.current = value;\n    }\n  });\n};\n\nconst useCanvasSingleton = /*#__PURE__*/createSingleton(() => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = 0;\n  canvas.height = 0;\n  return ctx;\n});\nconst Canvas = /*#__PURE__*/forwardRef(function Canvas({\n  index,\n  frames,\n  width,\n  height,\n  fit,\n  className,\n  style\n}, ref) {\n  const canvasRef = useRef();\n  const ctx = useRef();\n  const tempCtx = useCanvasSingleton();\n  useLayoutEffect(() => {\n    if (canvasRef.current) {\n      ctx.current = canvasRef.current.getContext(\"2d\");\n    }\n  }, [canvasRef]);\n  useLayoutEffect(() => {\n    if (canvasRef.current) {\n      canvasRef.current.width = width;\n      canvasRef.current.height = height;\n    }\n  }, [canvasRef, width, height]);\n  useEffect(() => {\n    const imageData = frames[index];\n\n    if (imageData) {\n      if (tempCtx.canvas.width < imageData.width || tempCtx.canvas.height < imageData.height) {\n        tempCtx.canvas.width = imageData.width;\n        tempCtx.canvas.height = imageData.height;\n      }\n\n      if (width > 0 && height > 0) {\n        ctx.current.clearRect(0, 0, width, height);\n        tempCtx.clearRect(0, 0, tempCtx.canvas.width, tempCtx.canvas.height);\n      }\n\n      tempCtx.putImageData(imageData, 0, 0);\n      ctx.current.drawImage(tempCtx.canvas, ...calcArgs(fit, imageData, {\n        width,\n        height\n      }));\n    }\n  }, [index, frames, width, height, fit]);\n  return /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: combine(canvasRef, ref),\n    className: className,\n    style: style\n  });\n});\n\nexport { Canvas, useParser, usePlayback, usePlayerState, useWorkerParser };\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deinterlace = void 0;\n\n/**\r\n * Deinterlace function from https://github.com/shachaf/jsgif\r\n */\nvar deinterlace = function deinterlace(pixels, width) {\n  var newPixels = new Array(pixels.length);\n  var rows = pixels.length / width;\n\n  var cpRow = function cpRow(toRow, fromRow) {\n    var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\n    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\n  }; // See appendix E.\n\n\n  var offsets = [0, 4, 2, 1];\n  var steps = [8, 8, 4, 2];\n  var fromRow = 0;\n\n  for (var pass = 0; pass < 4; pass++) {\n    for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\n      cpRow(toRow, fromRow);\n      fromRow++;\n    }\n  }\n\n  return newPixels;\n};\n\nexports.deinterlace = deinterlace;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompressFrames = exports.decompressFrame = exports.parseGIF = void 0;\n\nvar _gif = _interopRequireDefault(require(\"js-binary-schema-parser/lib/schemas/gif\"));\n\nvar _jsBinarySchemaParser = require(\"js-binary-schema-parser\");\n\nvar _uint = require(\"js-binary-schema-parser/lib/parsers/uint8\");\n\nvar _deinterlace = require(\"./deinterlace\");\n\nvar _lzw = require(\"./lzw\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar parseGIF = function parseGIF(arrayBuffer) {\n  var byteData = new Uint8Array(arrayBuffer);\n  return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif[\"default\"]);\n};\n\nexports.parseGIF = parseGIF;\n\nvar generatePatch = function generatePatch(image) {\n  var totalPixels = image.pixels.length;\n  var patchData = new Uint8ClampedArray(totalPixels * 4);\n\n  for (var i = 0; i < totalPixels; i++) {\n    var pos = i * 4;\n    var colorIndex = image.pixels[i];\n    var color = image.colorTable[colorIndex] || [0, 0, 0];\n    patchData[pos] = color[0];\n    patchData[pos + 1] = color[1];\n    patchData[pos + 2] = color[2];\n    patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;\n  }\n\n  return patchData;\n};\n\nvar decompressFrame = function decompressFrame(frame, gct, buildImagePatch) {\n  if (!frame.image) {\n    console.warn('gif frame does not have associated image.');\n    return;\n  }\n\n  var image = frame.image; // get the number of pixels\n\n  var totalPixels = image.descriptor.width * image.descriptor.height; // do lzw decompression\n\n  var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels); // deal with interlacing if necessary\n\n  if (image.descriptor.lct.interlaced) {\n    pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);\n  }\n\n  var resultImage = {\n    pixels: pixels,\n    dims: {\n      top: frame.image.descriptor.top,\n      left: frame.image.descriptor.left,\n      width: frame.image.descriptor.width,\n      height: frame.image.descriptor.height\n    }\n  }; // color table\n\n  if (image.descriptor.lct && image.descriptor.lct.exists) {\n    resultImage.colorTable = image.lct;\n  } else {\n    resultImage.colorTable = gct;\n  } // add per frame relevant gce information\n\n\n  if (frame.gce) {\n    resultImage.delay = (frame.gce.delay || 10) * 10; // convert to ms\n\n    resultImage.disposalType = frame.gce.extras.disposal; // transparency\n\n    if (frame.gce.extras.transparentColorGiven) {\n      resultImage.transparentIndex = frame.gce.transparentColorIndex;\n    }\n  } // create canvas usable imagedata if desired\n\n\n  if (buildImagePatch) {\n    resultImage.patch = generatePatch(resultImage);\n  }\n\n  return resultImage;\n};\n\nexports.decompressFrame = decompressFrame;\n\nvar decompressFrames = function decompressFrames(parsedGif, buildImagePatches) {\n  return parsedGif.frames.filter(function (f) {\n    return f.image;\n  }).map(function (f) {\n    return decompressFrame(f, parsedGif.gct, buildImagePatches);\n  });\n};\n\nexports.decompressFrames = decompressFrames;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lzw = void 0;\n\n/**\r\n * javascript port of java LZW decompression\r\n * Original java author url: https://gist.github.com/devunwired/4479231\r\n */\nvar lzw = function lzw(minCodeSize, data, pixelCount) {\n  var MAX_STACK_SIZE = 4096;\n  var nullCode = -1;\n  var npix = pixelCount;\n  var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n  var dstPixels = new Array(pixelCount);\n  var prefix = new Array(MAX_STACK_SIZE);\n  var suffix = new Array(MAX_STACK_SIZE);\n  var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.\n\n  data_size = minCodeSize;\n  clear = 1 << data_size;\n  end_of_information = clear + 1;\n  available = clear + 2;\n  old_code = nullCode;\n  code_size = data_size + 1;\n  code_mask = (1 << code_size) - 1;\n\n  for (code = 0; code < clear; code++) {\n    prefix[code] = 0;\n    suffix[code] = code;\n  } // Decode GIF pixel stream.\n\n\n  var datum, bits, count, first, top, pi, bi;\n  datum = bits = count = first = top = pi = bi = 0;\n\n  for (i = 0; i < npix;) {\n    if (top === 0) {\n      if (bits < code_size) {\n        // get the next byte\n        datum += data[bi] << bits;\n        bits += 8;\n        bi++;\n        continue;\n      } // Get the next code.\n\n\n      code = datum & code_mask;\n      datum >>= code_size;\n      bits -= code_size; // Interpret the code\n\n      if (code > available || code == end_of_information) {\n        break;\n      }\n\n      if (code == clear) {\n        // Reset decoder.\n        code_size = data_size + 1;\n        code_mask = (1 << code_size) - 1;\n        available = clear + 2;\n        old_code = nullCode;\n        continue;\n      }\n\n      if (old_code == nullCode) {\n        pixelStack[top++] = suffix[code];\n        old_code = code;\n        first = code;\n        continue;\n      }\n\n      in_code = code;\n\n      if (code == available) {\n        pixelStack[top++] = first;\n        code = old_code;\n      }\n\n      while (code > clear) {\n        pixelStack[top++] = suffix[code];\n        code = prefix[code];\n      }\n\n      first = suffix[code] & 0xff;\n      pixelStack[top++] = first; // add a new string to the table, but only if space is available\n      // if not, just continue with current table until a clear code is found\n      // (deferred clear code implementation as per GIF spec)\n\n      if (available < MAX_STACK_SIZE) {\n        prefix[available] = old_code;\n        suffix[available] = first;\n        available++;\n\n        if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {\n          code_size++;\n          code_mask += available;\n        }\n      }\n\n      old_code = in_code;\n    } // Pop a pixel off the pixel stack.\n\n\n    top--;\n    dstPixels[pi++] = pixelStack[top];\n    i++;\n  }\n\n  for (i = pi; i < npix; i++) {\n    dstPixels[i] = 0; // clear missing pixels\n  }\n\n  return dstPixels;\n};\n\nexports.lzw = lzw;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loop = exports.conditional = exports.parse = void 0;\n\nvar parse = function parse(stream, schema) {\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : result;\n\n  if (Array.isArray(schema)) {\n    schema.forEach(function (partSchema) {\n      return parse(stream, partSchema, result, parent);\n    });\n  } else if (typeof schema === 'function') {\n    schema(stream, result, parent, parse);\n  } else {\n    var key = Object.keys(schema)[0];\n\n    if (Array.isArray(schema[key])) {\n      parent[key] = {};\n      parse(stream, schema[key], result, parent[key]);\n    } else {\n      parent[key] = schema[key](stream, result, parent, parse);\n    }\n  }\n\n  return result;\n};\n\nexports.parse = parse;\n\nvar conditional = function conditional(schema, conditionFunc) {\n  return function (stream, result, parent, parse) {\n    if (conditionFunc(stream, result, parent)) {\n      parse(stream, schema, result, parent);\n    }\n  };\n};\n\nexports.conditional = conditional;\n\nvar loop = function loop(schema, continueFunc) {\n  return function (stream, result, parent, parse) {\n    var arr = [];\n\n    while (continueFunc(stream, result, parent)) {\n      var newParent = {};\n      parse(stream, schema, result, newParent);\n      arr.push(newParent);\n    }\n\n    return arr;\n  };\n};\n\nexports.loop = loop;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBits = exports.readArray = exports.readUnsigned = exports.readString = exports.peekBytes = exports.readBytes = exports.peekByte = exports.readByte = exports.buildStream = void 0;\n\n// Default stream and parsers for Uint8TypedArray data type\nvar buildStream = function buildStream(uint8Data) {\n  return {\n    data: uint8Data,\n    pos: 0\n  };\n};\n\nexports.buildStream = buildStream;\n\nvar readByte = function readByte() {\n  return function (stream) {\n    return stream.data[stream.pos++];\n  };\n};\n\nexports.readByte = readByte;\n\nvar peekByte = function peekByte() {\n  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return function (stream) {\n    return stream.data[stream.pos + offset];\n  };\n};\n\nexports.peekByte = peekByte;\n\nvar readBytes = function readBytes(length) {\n  return function (stream) {\n    return stream.data.subarray(stream.pos, stream.pos += length);\n  };\n};\n\nexports.readBytes = readBytes;\n\nvar peekBytes = function peekBytes(length) {\n  return function (stream) {\n    return stream.data.subarray(stream.pos, stream.pos + length);\n  };\n};\n\nexports.peekBytes = peekBytes;\n\nvar readString = function readString(length) {\n  return function (stream) {\n    return Array.from(readBytes(length)(stream)).map(function (value) {\n      return String.fromCharCode(value);\n    }).join('');\n  };\n};\n\nexports.readString = readString;\n\nvar readUnsigned = function readUnsigned(littleEndian) {\n  return function (stream) {\n    var bytes = readBytes(2)(stream);\n    return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];\n  };\n};\n\nexports.readUnsigned = readUnsigned;\n\nvar readArray = function readArray(byteSize, totalOrFunc) {\n  return function (stream, result, parent) {\n    var total = typeof totalOrFunc === 'function' ? totalOrFunc(stream, result, parent) : totalOrFunc;\n    var parser = readBytes(byteSize);\n    var arr = new Array(total);\n\n    for (var i = 0; i < total; i++) {\n      arr[i] = parser(stream);\n    }\n\n    return arr;\n  };\n};\n\nexports.readArray = readArray;\n\nvar subBitsTotal = function subBitsTotal(bits, startIndex, length) {\n  var result = 0;\n\n  for (var i = 0; i < length; i++) {\n    result += bits[startIndex + i] && Math.pow(2, length - i - 1);\n  }\n\n  return result;\n};\n\nvar readBits = function readBits(schema) {\n  return function (stream) {\n    var _byte = readByte()(stream); // convert the byte to bit array\n\n\n    var bits = new Array(8);\n\n    for (var i = 0; i < 8; i++) {\n      bits[7 - i] = !!(_byte & 1 << i);\n    } // convert the bit array to values based on the schema\n\n\n    return Object.keys(schema).reduce(function (res, key) {\n      var def = schema[key];\n\n      if (def.length) {\n        res[key] = subBitsTotal(bits, def.index, def.length);\n      } else {\n        res[key] = bits[def.index];\n      }\n\n      return res;\n    }, {});\n  };\n};\n\nexports.readBits = readBits;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _ = require(\"../\");\n\nvar _uint = require(\"../parsers/uint8\");\n\n// a set of 0x00 terminated subblocks\nvar subBlocksSchema = {\n  blocks: function blocks(stream) {\n    var terminator = 0x00;\n    var chunks = [];\n    var streamSize = stream.data.length;\n    var total = 0;\n\n    for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {\n      // catch corrupted files with no terminator\n      if (stream.pos + size >= streamSize) {\n        var availableSize = streamSize - stream.pos;\n        chunks.push((0, _uint.readBytes)(availableSize)(stream));\n        total += availableSize;\n        break;\n      }\n\n      chunks.push((0, _uint.readBytes)(size)(stream));\n      total += size;\n    }\n\n    var result = new Uint8Array(total);\n    var offset = 0;\n\n    for (var i = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset);\n      offset += chunks[i].length;\n    }\n\n    return result;\n  }\n}; // global control extension\n\nvar gceSchema = (0, _.conditional)({\n  gce: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    byteSize: (0, _uint.readByte)()\n  }, {\n    extras: (0, _uint.readBits)({\n      future: {\n        index: 0,\n        length: 3\n      },\n      disposal: {\n        index: 3,\n        length: 3\n      },\n      userInput: {\n        index: 6\n      },\n      transparentColorGiven: {\n        index: 7\n      }\n    })\n  }, {\n    delay: (0, _uint.readUnsigned)(true)\n  }, {\n    transparentColorIndex: (0, _uint.readByte)()\n  }, {\n    terminator: (0, _uint.readByte)()\n  }]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xf9;\n}); // image pipeline block\n\nvar imageSchema = (0, _.conditional)({\n  image: [{\n    code: (0, _uint.readByte)()\n  }, {\n    descriptor: [{\n      left: (0, _uint.readUnsigned)(true)\n    }, {\n      top: (0, _uint.readUnsigned)(true)\n    }, {\n      width: (0, _uint.readUnsigned)(true)\n    }, {\n      height: (0, _uint.readUnsigned)(true)\n    }, {\n      lct: (0, _uint.readBits)({\n        exists: {\n          index: 0\n        },\n        interlaced: {\n          index: 1\n        },\n        sort: {\n          index: 2\n        },\n        future: {\n          index: 3,\n          length: 2\n        },\n        size: {\n          index: 5,\n          length: 3\n        }\n      })\n    }]\n  }, (0, _.conditional)({\n    lct: (0, _uint.readArray)(3, function (stream, result, parent) {\n      return Math.pow(2, parent.descriptor.lct.size + 1);\n    })\n  }, function (stream, result, parent) {\n    return parent.descriptor.lct.exists;\n  }), {\n    data: [{\n      minCodeSize: (0, _uint.readByte)()\n    }, subBlocksSchema]\n  }]\n}, function (stream) {\n  return (0, _uint.peekByte)()(stream) === 0x2c;\n}); // plain text block\n\nvar textSchema = (0, _.conditional)({\n  text: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    preData: function preData(stream, result, parent) {\n      return (0, _uint.readBytes)(parent.text.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0x01;\n}); // application block\n\nvar applicationSchema = (0, _.conditional)({\n  application: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    id: function id(stream, result, parent) {\n      return (0, _uint.readString)(parent.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xff;\n}); // comment block\n\nvar commentSchema = (0, _.conditional)({\n  comment: [{\n    codes: (0, _uint.readBytes)(2)\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xfe;\n});\nvar schema = [{\n  header: [{\n    signature: (0, _uint.readString)(3)\n  }, {\n    version: (0, _uint.readString)(3)\n  }]\n}, {\n  lsd: [{\n    width: (0, _uint.readUnsigned)(true)\n  }, {\n    height: (0, _uint.readUnsigned)(true)\n  }, {\n    gct: (0, _uint.readBits)({\n      exists: {\n        index: 0\n      },\n      resolution: {\n        index: 1,\n        length: 3\n      },\n      sort: {\n        index: 4\n      },\n      size: {\n        index: 5,\n        length: 3\n      }\n    })\n  }, {\n    backgroundColorIndex: (0, _uint.readByte)()\n  }, {\n    pixelAspectRatio: (0, _uint.readByte)()\n  }]\n}, (0, _.conditional)({\n  gct: (0, _uint.readArray)(3, function (stream, result) {\n    return Math.pow(2, result.lsd.gct.size + 1);\n  })\n}, function (stream, result) {\n  return result.lsd.gct.exists;\n}), // content frames\n{\n  frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {\n    var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence\n    // of an ext or image block to avoid infinite loops\n    //var terminator = 0x3B;\n    //return nextCode !== terminator;\n\n    return nextCode === 0x21 || nextCode === 0x2c;\n  })\n}];\nvar _default = schema;\nexports[\"default\"] = _default;","!function(g,c){typeof exports==\"object\"&&typeof module!=\"undefined\"?c(exports):typeof define==\"function\"&&define.amd?define([\"exports\"],c):c((g=g||self).lru_map=g.lru_map||{})}(this,function(g){const c=Symbol(\"newer\"),e=Symbol(\"older\");class n{constructor(a,b){typeof a!==\"number\"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size))}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error(\"overflow\")}this.newest=b,this.size=this._keymap.size}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear()}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!==\"object\"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c]}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a=\"\",b=this.oldest;b;)a+=String(b.key)+\":\"+b.value,b=b[c],b&&(a+=\" < \");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0}function i(a){this.entry=a}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}}});\n//# sourceMappingURL=lru.js.map\n","import {Gif} from '@remotion/gif';\nimport {Sequence, staticFile, useVideoConfig} from 'remotion';\n\nconst GifTest: React.FC = () => {\n\tconst {width, height} = useVideoConfig();\n\tconst giphy = staticFile('giphy.gif');\n\n\treturn (\n\t\t<div style={{flex: 1, backgroundColor: 'black'}}>\n\t\t\t<Sequence from={0} durationInFrames={50}>\n\t\t\t\t<Gif src={giphy} width={width} height={height} fit=\"fill\" />\n\t\t\t</Sequence>\n\n\t\t\t<Sequence from={50} durationInFrames={50}>\n\t\t\t\t<Gif\n\t\t\t\t\tsrc=\"https://media.giphy.com/media/xT0GqH01ZyKwd3aT3G/giphy.gif\"\n\t\t\t\t\twidth={width}\n\t\t\t\t\theight={height}\n\t\t\t\t\tfit=\"cover\"\n\t\t\t\t/>\n\t\t\t</Sequence>\n\n\t\t\t<Sequence from={100} durationInFrames={50}>\n\t\t\t\t<Gif\n\t\t\t\t\tsrc=\"https://media.giphy.com/media/3o72F7YT6s0EMFI0Za/giphy.gif\"\n\t\t\t\t\twidth={width}\n\t\t\t\t\theight={height}\n\t\t\t\t\tfit=\"contain\"\n\t\t\t\t/>\n\t\t\t</Sequence>\n\t\t</div>\n\t);\n};\n\nexport default GifTest;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Gif = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst remotion_1 = require(\"remotion\");\nconst GifForDevelopment_1 = require(\"./GifForDevelopment\");\nconst GifForRendering_1 = require(\"./GifForRendering\");\nconst Gif = (props) => {\n    if (remotion_1.Internals.getRemotionEnvironment() === 'rendering') {\n        return (0, jsx_runtime_1.jsx)(GifForRendering_1.GifForRendering, { ...props });\n    }\n    return (0, jsx_runtime_1.jsx)(GifForDevelopment_1.GifForDevelopment, { ...props });\n};\nexports.Gif = Gif;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GifForDevelopment = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst tools_1 = require(\"@react-gifs/tools\");\nconst lru_map_1 = require(\"lru_map\");\nconst react_1 = require(\"react\");\nconst useCurrentGifIndex_1 = require(\"./useCurrentGifIndex\");\nconst cache = new lru_map_1.LRUMap(30);\nexports.GifForDevelopment = (0, react_1.forwardRef)(({ src, width, height, onError, onLoad, fit = 'fill', ...props }, ref) => {\n    const resolvedSrc = new URL(src, window.location.origin).href;\n    const [state, update] = (0, react_1.useState)(() => {\n        const parsedGif = cache.get(resolvedSrc);\n        if (parsedGif === undefined) {\n            return {\n                delays: [],\n                frames: [],\n                width: 0,\n                height: 0,\n            };\n        }\n        return parsedGif;\n    });\n    // skip loading if frames exist\n    (0, tools_1.useWorkerParser)(Boolean(state.frames.length) || resolvedSrc, (info) => {\n        if ('error' in info) {\n            if (onError) {\n                onError(info.error);\n            }\n            else {\n                console.error('Error loading GIF:', info.error, 'Handle the event using the onError() prop to make this message disappear.');\n            }\n        }\n        else {\n            onLoad === null || onLoad === void 0 ? void 0 : onLoad(info);\n            cache.set(resolvedSrc, info);\n            update(info);\n        }\n    });\n    const index = (0, useCurrentGifIndex_1.useCurrentGifIndex)(state.delays);\n    return ((0, jsx_runtime_1.jsx)(tools_1.Canvas, { fit: fit, index: index, frames: state.frames, width: width !== null && width !== void 0 ? width : state.width, height: height !== null && height !== void 0 ? height : state.height, ...props, ref: ref }));\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GifForRendering = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst tools_1 = require(\"@react-gifs/tools\");\nconst react_1 = require(\"react\");\nconst remotion_1 = require(\"remotion\");\nconst useCurrentGifIndex_1 = require(\"./useCurrentGifIndex\");\nexports.GifForRendering = (0, react_1.forwardRef)(({ src, width, height, onLoad, onError, fit = 'fill', ...props }, ref) => {\n    const resolvedSrc = new URL(src, window.location.origin).href;\n    const [state, update] = (0, react_1.useState)({\n        delays: [],\n        frames: [],\n        width: 0,\n        height: 0,\n    });\n    const [id] = (0, react_1.useState)(() => (0, remotion_1.delayRender)(`Rendering <Gif/> with src=\"${resolvedSrc}\"`));\n    const index = (0, useCurrentGifIndex_1.useCurrentGifIndex)(state.delays);\n    (0, tools_1.useParser)(resolvedSrc, (info) => {\n        if ('error' in info) {\n            if (onError) {\n                onError(info.error);\n            }\n            else {\n                console.error('Error loading GIF:', info.error, 'Handle the event using the onError() prop to make this message disappear.');\n            }\n        }\n        else {\n            onLoad === null || onLoad === void 0 ? void 0 : onLoad(info);\n            update(info);\n        }\n        (0, remotion_1.continueRender)(id);\n    });\n    return ((0, jsx_runtime_1.jsx)(tools_1.Canvas, { fit: fit, index: index, frames: state.frames, width: width !== null && width !== void 0 ? width : state.width, height: height !== null && height !== void 0 ? height : state.height, ...props, ref: ref }));\n});\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./Gif\"), exports);\n__exportStar(require(\"./props\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useCurrentGifIndex = void 0;\nconst react_1 = require(\"react\");\nconst remotion_1 = require(\"remotion\");\nfunction useCurrentGifIndex(delays) {\n    const currentFrame = (0, remotion_1.useCurrentFrame)();\n    const videoConfig = remotion_1.Internals.useUnsafeVideoConfig();\n    const duration = (0, react_1.useMemo)(() => {\n        if (delays.length !== 0) {\n            return delays.reduce((sum, delay) => sum + delay, 0);\n        }\n        return 1;\n    }, [delays]);\n    const index = (0, react_1.useMemo)(() => {\n        if (videoConfig && delays.length !== 0) {\n            let currentTime = ((currentFrame / videoConfig.fps) * 1000) % duration;\n            for (const [i, delay] of delays.entries()) {\n                if (currentTime < delay)\n                    return i;\n                currentTime -= delay;\n            }\n        }\n        return 0;\n    }, [delays, duration, currentFrame, videoConfig]);\n    return index;\n}\nexports.useCurrentGifIndex = useCurrentGifIndex;\n"],"names":[],"sourceRoot":""}